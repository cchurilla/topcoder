topcoder
========
this is the place where i'll store my topcoder attempts.
recall that topcoder problems are timed and one's score is directly proprotional to the time one takes to complete a problem.
corollarily documentation, elegant design, testability, amongst other things fall by the wayside when solving a problem. were one to scour other topcoder solutions, one would be hardpressed to find any of those concepts being employed, unless they somehow proved vital to solving the problem. 

in my case, while at times i'm tempted to use single letter variable names, generally i gamble with longer human readable variables in hopes that they'll help me reason through my struggles or more obviously prove my solution. i find the same holds for documentation when taking tricky twists and turns to reach some end. however, save for those two things, i suppose there is no semblance of "production code quality" in my solutions -- there just isn't time for them.

i think this speaks to the debt we pay to make production code maintainable, robust, testable, and the long term dividends those types of things pay and how they're well amortized as the project ages. 

a top coder problem rarely evolves, its solution rarely reused elsewhere, therefore one might argue most of the "production quality techinques/conventions" have come at too great of a price on solution score for topcoder. but this is maybe the only place i would argue where that holds true; i would argue almost anywhere else, the lack of these things will only prove deadly in some way. 

it's late at night, and this is a draft, so i'm going to leave this in its terrible meandering state.

you should not look to these problems to determine my object oriented proficiency.

what should you look to these for? i'll have to answer that later.
